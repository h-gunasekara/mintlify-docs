---
title: 'Pagination'
description: 'How to paginate through product results in the Catalog API'
---

# Pagination

The Catalog API uses page-based pagination to efficiently handle large result sets. This guide explains how to paginate through product results and how to use the pagination metadata.

## How Pagination Works

The API returns a limited number of products per request. By default, results are returned in pages of 10 items. You can request specific pages by including the `page` parameter in your request.

## Requesting a Specific Page

To request a specific page, include the `page` parameter in your request body:

<CodeGroup>
```json Request (Page 1)
{
  "query": "shirts",
  "page": 1
}
```

```json Request (Page 2)
{
  "query": "shirts",
  "page": 2
}
```
</CodeGroup>

<Note>
  Page numbers are 1-indexed, meaning the first page is page 1 (not 0).
</Note>

## Pagination Metadata

Every response includes a `meta` object with pagination details:

```json
{
  "products": [ ... ],
  "meta": {
    "totalItems": 42,   // Total number of products matching criteria
    "totalPages": 5,    // Total number of pages available
    "currentPage": 1,   // Current page number
    "pageSize": 10      // Number of items per page
  }
}
```

<Warning>
  The `totalItems` value is capped at 50 for performance reasons, even if the actual total count is higher.
</Warning>

## Implementing Pagination Controls

Here's an example of how to implement pagination controls in your application:

### JavaScript Example

```javascript
function renderPagination(meta) {
  const { currentPage, totalPages } = meta;
  
  // Determine which pages to show
  const showFirstPage = currentPage > 2;
  const showLastPage = currentPage < totalPages - 1;
  const pageNumbers = [];
  
  // Add page numbers to display
  if (showFirstPage) {
    pageNumbers.push(1);
    if (currentPage > 3) pageNumbers.push('...');
  }
  
  // Add previous page if not on first page
  if (currentPage > 1) pageNumbers.push(currentPage - 1);
  
  // Add current page
  pageNumbers.push(currentPage);
  
  // Add next page if not on last page
  if (currentPage < totalPages) pageNumbers.push(currentPage + 1);
  
  // Add last page
  if (showLastPage) {
    if (currentPage < totalPages - 2) pageNumbers.push('...');
    pageNumbers.push(totalPages);
  }
  
  // Create the navigation HTML
  const paginationHTML = `
    <div class="pagination">
      ${currentPage > 1 ? '<button class="prev">Previous</button>' : ''}
      ${pageNumbers.map(page => {
        if (page === '...') return '<span class="ellipsis">...</span>';
        return `<button class="page-number ${page === currentPage ? 'active' : ''}">${page}</button>`;
      }).join('')}
      ${currentPage < totalPages ? '<button class="next">Next</button>' : ''}
    </div>
  `;
  
  // Insert into the DOM
  document.getElementById('pagination-container').innerHTML = paginationHTML;
  
  // Add event listeners to buttons
  document.querySelectorAll('.page-number').forEach(button => {
    button.addEventListener('click', () => {
      if (button.classList.contains('active')) return;
      const pageNumber = parseInt(button.textContent);
      fetchPage(pageNumber);
    });
  });
  
  if (currentPage > 1) {
    document.querySelector('.prev').addEventListener('click', () => {
      fetchPage(currentPage - 1);
    });
  }
  
  if (currentPage < totalPages) {
    document.querySelector('.next').addEventListener('click', () => {
      fetchPage(currentPage + 1);
    });
  }
}

function fetchPage(pageNumber) {
  // Update UI to show loading state
  showLoadingState();
  
  // Make API request with the new page number
  fetchProducts({
    query: currentQuery,
    filters: currentFilters,
    page: pageNumber
  })
    .then(response => {
      // Update product list with new data
      renderProducts(response.products);
      
      // Update pagination controls
      renderPagination(response.meta);
      
      // Hide loading state
      hideLoadingState();
    })
    .catch(error => {
      // Handle error
      showErrorMessage(error);
      hideLoadingState();
    });
}
```

## Best Practices

### Maintain State

When implementing pagination, maintain the current search and filter state when navigating between pages:

```javascript
// Example state management
let currentState = {
  query: "shirts",
  filters: {
    price_min: 20,
    price_max: 100,
    is_available: true
  },
  page: 1
};

// When changing pages, only update the page parameter
function goToPage(newPage) {
  currentState = {
    ...currentState,
    page: newPage
  };
  
  // Make the API request with the updated state
  fetchProducts(currentState);
}
```

### Handle Empty Pages

If a user requests a page beyond the available pages, the API will return an empty `products` array:

```json
{
  "products": [],
  "meta": {
    "totalItems": 42,
    "totalPages": 5,
    "currentPage": 10,  // Beyond the available pages
    "pageSize": 10
  }
}
```

Handle this gracefully by checking for empty results and offering to return to a valid page:

```javascript
if (response.products.length === 0 && response.meta.totalItems > 0) {
  showMessage("No products found on this page.");
  offerToRedirect("Would you like to go to page 1?", () => {
    fetchPage(1);
  });
}
```

### Use Loading States

Always show loading states when fetching a new page to improve user experience:

```javascript
function fetchPage(pageNumber) {
  // Show loading state
  showLoadingIndicator();
  
  // Make API request
  fetchProducts({
    query: currentQuery,
    filters: currentFilters,
    page: pageNumber
  })
    .then(response => {
      // Update UI with new data
      updateProductList(response.products);
      updatePaginationControls(response.meta);
      
      // Hide loading state
      hideLoadingIndicator();
    })
    .catch(error => {
      // Handle error
      showError(error);
      hideLoadingIndicator();
    });
}
```

## Example: Infinite Scroll

For a modern user experience, you might implement infinite scroll instead of traditional pagination:

```javascript
let currentPage = 1;
let isLoading = false;
let hasMorePages = true;

// Detect when user scrolls near the bottom of the page
window.addEventListener('scroll', () => {
  if (isLoading || !hasMorePages) return;
  
  const scrollY = window.scrollY;
  const visibleHeight = document.documentElement.clientHeight;
  const pageHeight = document.documentElement.scrollHeight;
  const bottomOfPage = scrollY + visibleHeight >= pageHeight - 300;
  
  if (bottomOfPage) {
    loadNextPage();
  }
});

function loadNextPage() {
  isLoading = true;
  showLoadingIndicator();
  
  fetchProducts({
    query: currentQuery,
    filters: currentFilters,
    page: currentPage + 1
  })
    .then(response => {
      // Append new products to the existing list
      appendProducts(response.products);
      
      // Update pagination state
      currentPage = response.meta.currentPage;
      hasMorePages = currentPage < response.meta.totalPages;
      
      // Hide loading indicator
      hideLoadingIndicator();
      isLoading = false;
    })
    .catch(error => {
      console.error("Error loading next page:", error);
      hideLoadingIndicator();
      isLoading = false;
    });
}
```

## Related Guides

- [Request Structure](/developer-guide/request-structure) - Full API request format
- [Response Structure](/developer-guide/response-structure) - Details about API responses
- [Examples](/examples/javascript) - More code examples 
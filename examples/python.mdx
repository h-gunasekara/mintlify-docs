---
title: 'Python Examples'
description: 'Examples of using the Catalog API with Python'
---

# Python Examples

These examples demonstrate how to use the Catalog API with Python using the `requests` library.

<Note>
  Replace `YOUR_API_KEY` with your actual API key in all examples.
</Note>

## Setup

First, make sure you have the `requests` library installed:

```bash
pip install requests
```

Then, let's define a reusable function to call the API:

```python
import requests
import json
import os # Optional: for getting API key from environment variable

# Define API endpoint and key
API_ENDPOINT = "https://catalogai.vercel.app/api/products"
API_KEY = os.getenv("CATALOG_API_KEY", "YOUR_API_KEY") # Get from environment or use default

def fetch_products(body):
    """Sends a POST request to the product catalog API."""
    headers = {
        'Content-Type': 'application/json',
        'x-api-key': API_KEY
    }
    try:
        response = requests.post(API_ENDPOINT, headers=headers, json=body)
        # Raise an exception for bad status codes (4xx or 5xx)
        response.raise_for_status() 
        # Return the parsed JSON response on success
        return response.json() 
    except requests.exceptions.RequestException as e:
        # Handle connection errors, timeouts, etc.
        print(f"Request failed: {e}") 
        # Try to print error details from response if possible
        if e.response is not None:
            try:
                print(f"Error response: {e.response.json()}")
            except json.JSONDecodeError:
                print(f"Error response (non-JSON): {e.response.text}")
        # Re-raise the exception or handle it as needed
        raise 
    except json.JSONDecodeError:
        # Handle cases where the response is not valid JSON
        print("Failed to decode JSON response.")
        print(f"Raw response text: {response.text}")
        raise # Re-raise or handle
```

## Basic Search

Search for products matching "cotton shirt":

```python
# Example 1: Search for "cotton shirt"
try:
    data = fetch_products({"query": "cotton shirt"})
    print(f"Found {data['meta']['totalItems']} products")
    if data['products']:
        print(f"First product: {data['products'][0]['title']}")
except Exception as e:
    print(f"Error: {e}")
```

## Using Filters

Filter products by vendor, availability, and price range:

```python
# Example 2: Filter by vendor, availability, price
try:
    data = fetch_products({
        "filters": {
            "vendor": "EcoWear",
            "is_available": True, # Python boolean
            "price_min": 20.00,
            "price_max": 50.00
        }
    })
    print(f"Found {data['meta']['totalItems']} products")
    if data['products']:
        prices = [p['price_display'] for p in data['products']]
        print(f"Price range: {min(prices)} - {max(prices)} USD")
except Exception as e:
    print(f"Error: {e}")
```

## Filtering by Attributes

Filter products by color and fabric:

```python
# Example 3: Filter by attributes (color, fabric)
try:
    data = fetch_products({
        "filters": {
            "attributes": {
                "color": "Green",
                "fabric": ["linen"]
            }
        }
    })
    print(f"Found {data['meta']['totalItems']} green linen products")
except Exception as e:
    print(f"Error: {e}")
```

## Combined Search and Filters

Search for "jacket" and filter by vendor:

```python
# Example 4: Combine search and filter
try:
    data = fetch_products({
        "query": "jacket",
        "filters": {"vendor": "TrailBlazer"}
    })
    print(f"Found {data['meta']['totalItems']} TrailBlazer jackets")
except Exception as e:
    print(f"Error: {e}")
```

## Pagination

Get the second page of search results for "shoes":

```python
# Example 5: Search with pagination (page 2)
try:
    data = fetch_products({
        "query": "shoes",
        "page": 2
    })
    print(f"Page {data['meta']['currentPage']} of {data['meta']['totalPages']}")
    start_item = (data['meta']['currentPage'] - 1) * data['meta']['pageSize'] + 1
    end_item = min(data['meta']['currentPage'] * data['meta']['pageSize'], data['meta']['totalItems'])
    print(f"Showing products {start_item}-{end_item} of {data['meta']['totalItems']}")
except Exception as e:
    print(f"Error: {e}")
```

## Complete Script Example

Here's a complete Python script that allows you to search products from the command line:

```python
#!/usr/bin/env python3
import requests
import json
import argparse
import sys
import os
from typing import Dict, Any, List, Optional

API_ENDPOINT = "https://catalogai.vercel.app/api/products"
API_KEY = os.getenv("CATALOG_API_KEY", "YOUR_API_KEY")

def search_products(
    query: Optional[str] = None,
    vendor: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    color: Optional[str] = None,
    available_only: bool = False,
    page: int = 1
) -> Dict[str, Any]:
    """
    Search for products with the given parameters.
    
    Args:
        query: Search term
        vendor: Filter by vendor name
        min_price: Minimum price filter
        max_price: Maximum price filter
        color: Filter by color
        available_only: Only show available products
        page: Page number
        
    Returns:
        API response as a dictionary
    """
    # Build request body
    body: Dict[str, Any] = {"page": page}
    
    if query:
        body["query"] = query
    
    # Initialize filters if any filter parameter is provided
    filters: Dict[str, Any] = {}
    
    if vendor:
        filters["vendor"] = vendor
    
    if min_price is not None:
        filters["price_min"] = min_price
    
    if max_price is not None:
        filters["price_max"] = max_price
    
    if available_only:
        filters["is_available"] = True
    
    # Add attribute filters if provided
    attribute_filters: Dict[str, Any] = {}
    
    if color:
        attribute_filters["color"] = color
    
    if attribute_filters:
        filters["attributes"] = attribute_filters
    
    # Add filters to body if any exist
    if filters:
        body["filters"] = filters
    
    # Make API request
    headers = {
        'Content-Type': 'application/json',
        'x-api-key': API_KEY
    }
    
    try:
        response = requests.post(API_ENDPOINT, headers=headers, json=body)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error: {e}", file=sys.stderr)
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_data = e.response.json()
                print(f"API Error: {error_data.get('error', 'Unknown error')}", file=sys.stderr)
            except json.JSONDecodeError:
                print(f"API Response: {e.response.text}", file=sys.stderr)
        sys.exit(1)

def display_product(product: Dict[str, Any]) -> None:
    """Display a product in a readable format"""
    print(f"[{product['id']}] {product['title']}")
    print(f"  Vendor: {product['vendor']}")
    print(f"  Price: ${product['price_display']} USD")
    print(f"  Available: {'Yes' if product['is_available'] else 'No'}")
    
    if 'attributes' in product and product['attributes']:
        attr = product['attributes']
        if 'color' in attr:
            print(f"  Color: {attr['color']}")
        if 'category' in attr:
            print(f"  Category: {attr['category']}")
        if 'fabric' in attr and attr['fabric']:
            fabrics = [f for f, v in attr['fabric'].items() if v]
            if fabrics:
                print(f"  Fabric: {', '.join(fabrics)}")
    
    print(f"  URL: {product['url']}")
    print()

def main():
    parser = argparse.ArgumentParser(description="Search for products in the catalog")
    parser.add_argument("-q", "--query", help="Search term")
    parser.add_argument("-v", "--vendor", help="Filter by vendor")
    parser.add_argument("--min", type=float, help="Minimum price")
    parser.add_argument("--max", type=float, help="Maximum price")
    parser.add_argument("-c", "--color", help="Filter by color")
    parser.add_argument("-a", "--available", action="store_true", help="Only show available products")
    parser.add_argument("-p", "--page", type=int, default=1, help="Page number")
    
    args = parser.parse_args()
    
    # Require at least one search parameter
    if not any([args.query, args.vendor, args.min, args.max, args.color, args.available]):
        parser.error("At least one search parameter is required")
    
    # Perform the search
    results = search_products(
        query=args.query,
        vendor=args.vendor,
        min_price=args.min,
        max_price=args.max,
        color=args.color,
        available_only=args.available,
        page=args.page
    )
    
    # Display results
    meta = results['meta']
    products = results['products']
    
    print(f"Found {meta['totalItems']} products (page {meta['currentPage']} of {meta['totalPages']})")
    print("-" * 50)
    
    if not products:
        print("No products found for this query/page.")
    else:
        for product in products:
            display_product(product)
    
    # Show pagination info
    if meta['totalPages'] > 1:
        print(f"Page {meta['currentPage']} of {meta['totalPages']}")
        if meta['currentPage'] < meta['totalPages']:
            print(f"Use --page {meta['currentPage'] + 1} to see the next page")

if __name__ == "__main__":
    main()
```

To use this script:

```bash
# Basic search
python catalog_search.py -q "cotton shirt"

# Filter by price and vendor
python catalog_search.py -v "EcoWear" --min 20 --max 50

# Search for available products of a specific color
python catalog_search.py -q "jacket" -c "Blue" -a

# Go to page 2 of results
python catalog_search.py -q "shoes" -p 2
```

## Using with FastAPI

Here's an example of using the Catalog API with FastAPI to create a proxy API:

```python
from fastapi import FastAPI, HTTPException, Depends, Header
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List, Union
import requests
import os

app = FastAPI(title="Product Catalog Proxy API")

API_ENDPOINT = "https://catalogai.vercel.app/api/products"
API_KEY = os.getenv("CATALOG_API_KEY", "YOUR_API_KEY")

# Request models
class ProductAttributes(BaseModel):
    color: Optional[Union[str, List[str]]] = None
    fabric: Optional[List[str]] = None
    category: Optional[str] = None

class ProductFilters(BaseModel):
    price_min: Optional[float] = None
    price_max: Optional[float] = None
    vendor: Optional[Union[str, List[str]]] = None
    is_available: Optional[bool] = None
    attributes: Optional[ProductAttributes] = None

class SearchRequest(BaseModel):
    query: Optional[str] = None
    filters: Optional[ProductFilters] = None
    page: int = Field(default=1, ge=1)

# Simple API key auth for the proxy
async def verify_api_key(x_api_key: str = Header(...)):
    if x_api_key != "YOUR_PROXY_API_KEY":  # Set your own proxy API key
        raise HTTPException(status_code=401, detail="Invalid API key")
    return x_api_key

@app.post("/products")
async def search_products(
    request: SearchRequest,
    api_key: str = Depends(verify_api_key)
):
    """
    Search for products in the catalog.
    This endpoint proxies requests to the upstream Catalog API.
    """
    try:
        response = requests.post(
            API_ENDPOINT,
            headers={
                'Content-Type': 'application/json',
                'x-api-key': API_KEY
            },
            json=request.dict(exclude_none=True),
            timeout=10  # Set a reasonable timeout
        )
        
        # Try to get JSON response even if status code indicates error
        try:
            data = response.json()
        except requests.exceptions.JSONDecodeError:
            raise HTTPException(
                status_code=502,
                detail="Invalid response from upstream API"
            )
        
        # Check for API errors
        if not response.ok:
            raise HTTPException(
                status_code=response.status_code,
                detail=data.get('error', "Error from upstream API")
            )
        
        return data
        
    except requests.exceptions.Timeout:
        raise HTTPException(
            status_code=504,
            detail="Upstream API request timed out"
        )
    except requests.exceptions.ConnectionError:
        raise HTTPException(
            status_code=502,
            detail="Could not connect to upstream API"
        )
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Internal server error: {str(e)}"
        )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000) 
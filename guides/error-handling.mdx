---
title: "Error Handling"
description: "Handle API errors gracefully and provide great user experiences"
---

The Catalog API returns structured error responses with specific codes and messages. Learn how to handle different error scenarios in your application.

## Error Response Format

All API errors follow a consistent structure:

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error description",
    "details": {
      // Additional context when available
    }
  }
}
```

## Common Error Codes

### Authentication Errors

<ResponseExample>

```json 401 Unauthorized
{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Invalid or missing API key"
  }
}
```

```json 403 Forbidden
{
  "error": {
    "code": "FORBIDDEN",
    "message": "API key access denied"
  }
}
```

</ResponseExample>

### Validation Errors

<ResponseExample>

```json 400 Bad Request
{
  "error": {
    "code": "INVALID_PARAMETER",
    "message": "The 'price_min' parameter must be a positive number",
    "details": {
      "parameter": "price_min",
      "expected": "positive number",
      "received": "-100"
    }
  }
}
```

```json 400 Malformed JSON
{
  "error": {
    "code": "INVALID_JSON",
    "message": "Request body contains invalid JSON"
  }
}
```

</ResponseExample>

### Rate Limiting

<ResponseExample>

```json 429 Too Many Requests
{
  "error": {
    "code": "RATE_LIMITED",
    "message": "Rate limit exceeded. Try again in 60 seconds.",
    "details": {
      "retryAfter": 60,
      "limit": 1000,
      "remaining": 0
    }
  }
}
```

</ResponseExample>

### Resource Errors

<ResponseExample>

```json 404 Not Found
{
  "error": {
    "code": "NOT_FOUND",
    "message": "Product with ID '12345' not found"
  }
}
```

</ResponseExample>

### Server Errors

<ResponseExample>

```json 500 Internal Server Error
{
  "error": {
    "code": "INTERNAL_ERROR",
    "message": "An unexpected error occurred. Please try again."
  }
}
```

</ResponseExample>

## Implementation Patterns

### Basic Error Handling

<CodeGroup>

```javascript JavaScript
const searchProducts = async (query, filters = {}) => {
  try {
    const response = await fetch('https://catalogai.vercel.app/api/search', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.CATALOG_API_KEY
      },
      body: JSON.stringify({ query, filters })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new APIError(
        errorData.error.code,
        errorData.error.message,
        response.status,
        errorData.error.details
      );
    }

    return await response.json();
  } catch (error) {
    if (error instanceof APIError) {
      throw error;
    }
    
    // Network or other errors
    throw new Error('Failed to search products. Please check your connection.');
  }
};

class APIError extends Error {
  constructor(code, message, status, details = null) {
    super(message);
    this.name = 'APIError';
    this.code = code;
    this.status = status;
    this.details = details;
  }
}
```

```python Python
import requests
from typing import Optional, Dict, Any

class CatalogAPIError(Exception):
    def __init__(self, code: str, message: str, status: int, details: Optional[Dict] = None):
        super().__init__(message)
        self.code = code
        self.status = status
        self.details = details

class CatalogAPI:
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = 'https://catalogai.vercel.app'
    
    def search_products(self, query: str, filters: Optional[Dict] = None):
        try:
            response = requests.post(
                f'{self.base_url}/api/search',
                headers={
                    'Content-Type': 'application/json',
                    'x-api-key': self.api_key
                },
                json={'query': query, 'filters': filters or {}}
            )
            
            if not response.ok:
                error_data = response.json()
                error_info = error_data.get('error', {})
                
                raise CatalogAPIError(
                    code=error_info.get('code', 'UNKNOWN'),
                    message=error_info.get('message', 'Unknown error'),
                    status=response.status_code,
                    details=error_info.get('details')
                )
            
            return response.json()
            
        except requests.exceptions.RequestException as e:
            raise CatalogAPIError(
                code='NETWORK_ERROR',
                message=f'Network error: {str(e)}',
                status=0
            )
```

</CodeGroup>

### Retry Logic

<CodeGroup>

```javascript Exponential Backoff
const searchWithRetry = async (query, filters = {}, maxRetries = 3) => {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await searchProducts(query, filters);
    } catch (error) {
      if (error instanceof APIError) {
        // Don't retry client errors (4xx)
        if (error.status >= 400 && error.status < 500) {
          if (error.code === 'RATE_LIMITED') {
            // Handle rate limiting specially
            const retryAfter = error.details?.retryAfter || 60;
            if (attempt < maxRetries) {
              await sleep(retryAfter * 1000);
              continue;
            }
          }
          throw error; // Don't retry other 4xx errors
        }
        
        // Retry server errors (5xx) with exponential backoff
        if (error.status >= 500 && attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s
          await sleep(delay);
          continue;
        }
      }
      
      // Network errors - retry with backoff
      if (attempt < maxRetries) {
        const delay = Math.pow(2, attempt) * 1000;
        await sleep(delay);
        continue;
      }
      
      throw error;
    }
  }
};

const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
```

```python Python Retry
import time
import random
from typing import Optional, Dict

class CatalogAPIWithRetry(CatalogAPI):
    def search_products_with_retry(
        self, 
        query: str, 
        filters: Optional[Dict] = None, 
        max_retries: int = 3
    ):
        for attempt in range(max_retries + 1):
            try:
                return self.search_products(query, filters)
                
            except CatalogAPIError as e:
                # Don't retry client errors except rate limiting
                if 400 <= e.status < 500:
                    if e.code == 'RATE_LIMITED':
                        retry_after = e.details.get('retryAfter', 60) if e.details else 60
                        if attempt < max_retries:
                            time.sleep(retry_after)
                            continue
                    raise e
                
                # Retry server errors with exponential backoff
                if e.status >= 500 and attempt < max_retries:
                    delay = (2 ** attempt) + random.uniform(0, 1)
                    time.sleep(delay)
                    continue
                    
                raise e
                
            except Exception as e:
                # Network errors - retry with backoff
                if attempt < max_retries:
                    delay = (2 ** attempt) + random.uniform(0, 1)
                    time.sleep(delay)
                    continue
                raise e
```

</CodeGroup>

### User-Friendly Error Messages

<CodeGroup>

```javascript React Error Component
import { useState } from 'react';

const ProductSearch = () => {
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);
  const [products, setProducts] = useState([]);

  const handleSearch = async (query, filters) => {
    setLoading(true);
    setError(null);

    try {
      const data = await searchProducts(query, filters);
      setProducts(data.products);
    } catch (error) {
      setError(getErrorMessage(error));
    } finally {
      setLoading(false);
    }
  };

  const getErrorMessage = (error) => {
    if (error instanceof APIError) {
      switch (error.code) {
        case 'UNAUTHORIZED':
          return 'Authentication failed. Please check your API key.';
        case 'RATE_LIMITED':
          return 'Too many requests. Please try again in a moment.';
        case 'INVALID_PARAMETER':
          return `Invalid parameter: ${error.details?.parameter || 'unknown'}`;
        case 'NOT_FOUND':
          return 'Product not found.';
        case 'INTERNAL_ERROR':
          return 'Service temporarily unavailable. Please try again.';
        default:
          return 'Something went wrong. Please try again.';
      }
    }
    
    return 'Network error. Please check your connection and try again.';
  };

  const retrySearch = () => {
    // Retry the last search
    handleSearch(/* last query and filters */);
  };

  return (
    <div>
      {error && (
        <div className="bg-red-50 border border-red-200 rounded p-4 mb-4">
          <div className="text-red-800">{error}</div>
          <button 
            onClick={retrySearch}
            className="mt-2 text-red-600 underline"
          >
            Try again
          </button>
        </div>
      )}
      
      {/* Search UI */}
    </div>
  );
};
```

</CodeGroup>

### Graceful Degradation

<CodeGroup>

```javascript Fallback Strategies
const searchWithFallback = async (query, filters = {}) => {
  try {
    // Try the full search first
    return await searchProducts(query, filters);
  } catch (error) {
    if (error instanceof APIError) {
      // If specific filters failed, try with relaxed filters
      if (error.code === 'INVALID_PARAMETER' && Object.keys(filters).length > 0) {
        console.warn('Filters failed, trying without filters');
        try {
          return await searchProducts(query, {});
        } catch (fallbackError) {
          // If that also fails, return empty results
          return { products: [], meta: { totalItems: 0 } };
        }
      }
      
      // For rate limiting, return cached results if available
      if (error.code === 'RATE_LIMITED') {
        const cached = getCachedResults(query, filters);
        if (cached) {
          return cached;
        }
      }
    }
    
    // Return empty results for graceful degradation
    return { 
      products: [], 
      meta: { 
        totalItems: 0,
        error: 'Search temporarily unavailable'
      } 
    };
  }
};
```

</CodeGroup>

## Error Monitoring

### Logging and Analytics

<CodeGroup>

```javascript Error Tracking
const logError = (error, context = {}) => {
  const errorData = {
    timestamp: new Date().toISOString(),
    error: {
      name: error.name,
      message: error.message,
      code: error.code || 'UNKNOWN',
      status: error.status || 0
    },
    context,
    userAgent: navigator.userAgent,
    url: window.location.href
  };

  // Send to your error tracking service
  console.error('API Error:', errorData);
  
  // Example: Send to external service
  if (typeof gtag !== 'undefined') {
    gtag('event', 'exception', {
      description: `${error.code}: ${error.message}`,
      fatal: false
    });
  }
};

const searchProducts = async (query, filters) => {
  try {
    // ... search logic
  } catch (error) {
    logError(error, { query, filters });
    throw error;
  }
};
```

</CodeGroup>

## API Status Monitoring

Check API health before making requests:

<CodeGroup>

```javascript Health Check
const checkAPIHealth = async () => {
  try {
    const response = await fetch('https://catalogai.vercel.app/api/health', {
      method: 'GET',
      headers: {
        'x-api-key': process.env.CATALOG_API_KEY
      }
    });
    
    return response.ok;
  } catch {
    return false;
  }
};

const searchWithHealthCheck = async (query, filters) => {
  const isHealthy = await checkAPIHealth();
  
  if (!isHealthy) {
    throw new Error('API is currently unavailable. Please try again later.');
  }
  
  return searchProducts(query, filters);
};
```

</CodeGroup>

## Best Practices

### Error Boundaries (React)

<CodeGroup>

```javascript Error Boundary
import React from 'react';

class APIErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('API Error Boundary:', error, errorInfo);
    
    // Log to error tracking service
    logError(error, { 
      component: 'APIErrorBoundary',
      errorInfo 
    });
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="text-center py-8">
          <h2 className="text-xl font-semibold mb-4">Something went wrong</h2>
          <p className="text-gray-600 mb-4">
            We're experiencing technical difficulties. Please try again.
          </p>
          <button 
            onClick={() => this.setState({ hasError: false, error: null })}
            className="bg-blue-500 text-white px-4 py-2 rounded"
          >
            Try Again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Usage
const App = () => (
  <APIErrorBoundary>
    <ProductSearch />
  </APIErrorBoundary>
);
```

</CodeGroup>

### Timeout Handling

<CodeGroup>

```javascript Request Timeout
const searchWithTimeout = async (query, filters, timeout = 10000) => {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch('https://catalogai.vercel.app/api/search', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': process.env.CATALOG_API_KEY
      },
      body: JSON.stringify({ query, filters }),
      signal: controller.signal
    });

    clearTimeout(timeoutId);
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new APIError(
        errorData.error.code,
        errorData.error.message,
        response.status,
        errorData.error.details
      );
    }

    return await response.json();
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error('Request timed out. Please try again.');
    }
    
    throw error;
  }
};
```

</CodeGroup>

<Tip>
  Always provide meaningful error messages to users and implement appropriate retry logic for temporary failures. Consider caching successful responses to provide fallbacks during outages.
</Tip>